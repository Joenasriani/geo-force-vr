<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flyby - Procedural Flight Sim</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; }
        
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0f0;
            text-shadow: 1px 1px 2px #000;
            pointer-events: none;
            z-index: 10;
        }

        .hud-panel {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #0f0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            min-width: 200px;
        }

        .hud-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 16px;
            font-weight: bold;
        }

        #controls-hint {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            text-shadow: 1px 1px 2px #000;
            pointer-events: none;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(0, 255, 0, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        
        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: #0f0;
            transform: translate(-50%, -50%);
            border-radius: 50%;
        }

        /* Loading Overlay */
        #loader {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #0f0;
            font-size: 24px;
            z-index: 1000;
            transition: opacity 1s ease-out;
            pointer-events: none; /* Prevents blocking if JS fails */
        }
    </style>
</head>
<body>

    <div id="loader">INITIALIZING SYSTEMS...</div>

    <!-- HUD -->
    <div id="hud">
        <div class="hud-panel">
            <div style="border-bottom: 1px solid #0f0; margin-bottom: 10px; padding-bottom: 5px;">FLIGHT DATA</div>
            <div class="hud-row"><span>SPD:</span> <span id="speed">0</span> km/h</div>
            <div class="hud-row"><span>ALT:</span> <span id="alt">0</span> ft</div>
            <div class="hud-row"><span>HDG:</span> <span id="hdg">000</span>Â°</div>
            <div class="hud-row"><span>THR:</span> <span id="thr">0</span>%</div>
        </div>
    </div>

    <div id="crosshair"></div>
    
    <div id="controls-hint">
        ARROWS: Pitch/Roll | Q/E: Rudder | W/S: Throttle | SPACE: Engine Start/Stop
    </div>

    <!-- Import Three.js (Updated to r160 for CapsuleGeometry support) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r160/three.min.js"></script>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            maxSpeed: 2000,
            minSpeed: 150,
            turnSpeed: 1.5,
            terrainScale: 0.002,
            terrainHeight: 600,
            chunkSize: 20000
        };

        // --- STATE ---
        const state = {
            speed: 0, // km/h
            throttle: 0, // 0-1
            altitude: 2000,
            heading: 0,
            pitch: 0,
            roll: 0,
            engineOn: false,
            keys: {}
        };

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 1000, 15000);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 50000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(100, 1000, 100);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- AIRCRAFT BUILDER ---
        function createAircraft() {
            const aircraft = new THREE.Group();

            // Materials
            const fuselageMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.4, metalness: 0.6 });
            const glassMat = new THREE.MeshPhongMaterial({ color: 0x111111, shininess: 100, opacity: 0.9, transparent: true });
            const highlightMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });

            // Body
            const bodyGeo = new THREE.ConeGeometry(0.8, 8, 32);
            bodyGeo.rotateX(Math.PI / 2);
            const body = new THREE.Mesh(bodyGeo, fuselageMat);
            aircraft.add(body);

            // Cockpit (Requires Three.js r137+)
            const cockpitGeo = new THREE.CapsuleGeometry(0.7, 2, 4, 8);
            cockpitGeo.rotateX(Math.PI / 2);
            const cockpit = new THREE.Mesh(cockpitGeo, glassMat);
            cockpit.position.set(0, 0.8, 0.5);
            aircraft.add(cockpit);

            // Wings
            const wingGeo = new THREE.BoxGeometry(10, 0.2, 3);
            const wings = new THREE.Mesh(wingGeo, fuselageMat);
            wings.position.set(0, 0, 1);
            // Wing tips
            const wingTipGeo = new THREE.BoxGeometry(0.2, 0.2, 3);
            const leftTip = new THREE.Mesh(wingTipGeo, highlightMat);
            leftTip.position.set(5, 0, 1);
            const rightTip = new THREE.Mesh(wingTipGeo, highlightMat);
            rightTip.position.set(-5, 0, 1);
            
            aircraft.add(wings);
            aircraft.add(leftTip);
            aircraft.add(rightTip);

            // Tail
            const tailGeo = new THREE.BoxGeometry(3, 0.2, 2);
            const tail = new THREE.Mesh(tailGeo, fuselageMat);
            tail.position.set(0, 0.5, 3.5);
            aircraft.add(tail);

            const rudderGeo = new THREE.BoxGeometry(0.2, 2, 1.5);
            const rudder = new THREE.Mesh(rudderGeo, fuselageMat);
            rudder.position.set(0, 1, 3.5);
            rudder.rotation.x = -0.2;
            aircraft.add(rudder);

            // Engine Flame (Visual)
            const flameGeo = new THREE.ConeGeometry(0.4, 2, 8);
            flameGeo.rotateX(-Math.PI / 2);
            const flameMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.8 });
            const flame = new THREE.Mesh(flameGeo, flameMat);
            flame.position.set(0, 0, 5);
            flame.visible = false;
            aircraft.userData.flame = flame;
            aircraft.add(flame);

            aircraft.castShadow = true;
            return aircraft;
        }

        const plane = createAircraft();
        scene.add(plane);

        // --- PROCEDURAL TERRAIN ---
        // We use a shader material to displace vertices based on world position
        // This simulates infinite terrain without generating new geometry
        
        const vertexShader = `
            uniform float uTime;
            uniform float uScale;
            uniform float uHeight;
            varying float vHeight;
            varying vec3 vPos;
            
            // Simplex Noise Helper (Simplified for GLSL)
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
            
            float snoise(vec2 v) {
                const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
                vec2 i  = floor(v + dot(v, C.yy) );
                vec2 x0 = v -   i + dot(i, C.xx);
                vec2 i1;
                i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                vec4 x12 = x0.xyxy + C.xxzz;
                x12.xy -= i1;
                i = mod289(i);
                vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));
                vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
                m = m*m ;
                m = m*m ;
                vec3 x = 2.0 * fract(p * C.www) - 1.0;
                vec3 h = abs(x) - 0.5;
                vec3 ox = floor(x + 0.5);
                vec3 a0 = x - ox;
                m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
                vec3 g;
                g.x  = a0.x  * x0.x  + h.x  * x0.y;
                g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                return 130.0 * dot(m, g);
            }

            void main() {
                vPos = (modelMatrix * vec4(position, 1.0)).xyz;
                
                // Multi-fractal noise for detail
                float n = snoise(vPos.xz * uScale);
                n += 0.5 * snoise(vPos.xz * uScale * 2.0);
                n += 0.25 * snoise(vPos.xz * uScale * 4.0);
                
                vHeight = n * uHeight;
                
                // Flatten valleys for "water"
                if (vHeight < -200.0) vHeight = -200.0;

                vec3 newPos = position;
                newPos.y = vHeight; 
                
                // We don't actually displace the mesh geometry Y in world space relative to the plane here 
                // because we move the whole mesh plane. 
                // Instead, we just use world XZ to determine local Y.
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);
            }
        `;

        const fragmentShader = `
            varying float vHeight;
            varying vec3 vPos;

            void main() {
                vec3 color;
                
                // Color ramp based on height
                if (vHeight < -150.0) {
                    color = vec3(0.0, 0.3, 0.7); // Water
                } else if (vHeight < -50.0) {
                    color = vec3(0.76, 0.7, 0.5); // Sand
                } else if (vHeight < 300.0) {
                    color = vec3(0.1, 0.5, 0.1); // Grass
                } else if (vHeight < 500.0) {
                    color = vec3(0.4, 0.4, 0.4); // Rock
                } else {
                    color = vec3(1.0, 1.0, 1.0); // Snow
                }
                
                // Add a simple grid overlay effect for "simulation" feel
                float grid = abs(sin(vPos.x * 0.05)) * abs(sin(vPos.z * 0.05));
                if(grid > 0.95) color += vec3(0.1);

                // Simple lighting approximation
                float light = 0.8; // Ambient
                
                gl_FragColor = vec4(color * light, 1.0);
            }
        `;

        // The ground is a single large plane that moves with the aircraft
        const groundGeo = new THREE.PlaneGeometry(30000, 30000, 200, 200);
        groundGeo.rotateX(-Math.PI / 2);
        
        const groundMat = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: {
                uTime: { value: 0 },
                uScale: { value: CONFIG.terrainScale },
                uHeight: { value: CONFIG.terrainHeight }
            },
            wireframe: false
        });

        const ground = new THREE.Mesh(groundGeo, groundMat);
        scene.add(ground);


        // --- AUDIO SYSTEM (Synthesizer) ---
        let audioCtx;
        let engineOsc, engineGain;
        
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            if(engineOsc) return; // Already init
            
            engineOsc = audioCtx.createOscillator();
            engineGain = audioCtx.createGain();
            
            engineOsc.type = 'sawtooth';
            engineOsc.frequency.value = 50;
            engineOsc.connect(engineGain);
            engineGain.connect(audioCtx.destination);
            engineOsc.start();
            engineGain.gain.value = 0;
        }

        function updateAudio(throttle) {
            if(!engineOsc) return;
            // Pitch rises with throttle
            const targetFreq = 60 + (throttle * 400); 
            // Smooth transitions
            engineOsc.frequency.setTargetAtTime(targetFreq, audioCtx.currentTime, 0.1);
            
            // Volume Jitter for realism
            const jitter = Math.random() * 0.05;
            engineGain.gain.setTargetAtTime((throttle * 0.2) + jitter, audioCtx.currentTime, 0.1);
        }


        // --- INPUT HANDLING ---
        window.addEventListener('keydown', (e) => {
            state.keys[e.key.toLowerCase()] = true;
            state.keys[e.code] = true;
            if(e.code === 'Space') {
                if(!state.engineOn) {
                    state.engineOn = true;
                    initAudio();
                } else {
                    state.engineOn = false;
                    if(engineGain && audioCtx) engineGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.5);
                }
            }
        });
        
        window.addEventListener('keyup', (e) => {
            state.keys[e.key.toLowerCase()] = false;
            state.keys[e.code] = false;
        });
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });


        // --- FLIGHT PHYSICS ENGINE ---
        // Quaternion-based flight mechanics
        const velocity = new THREE.Vector3();
        const orientation = new THREE.Quaternion();
        
        // Initial Position
        plane.position.set(0, 2000, 0); 
        
        // Helper vectors
        const forward = new THREE.Vector3(0, 0, -1);
        const up = new THREE.Vector3(0, 1, 0);
        const axis = new THREE.Vector3();
        
        function updatePhysics(dt) {
            
            // 1. Throttle Logic
            if(state.keys['w']) state.throttle += 0.5 * dt;
            if(state.keys['s']) state.throttle -= 0.5 * dt;
            state.throttle = Math.max(0, Math.min(1, state.throttle));

            // Target Speed calculation
            const targetSpeed = state.engineOn ? (state.throttle * CONFIG.maxSpeed) : 0;
            // Accelerate/Decelerate towards target
            state.speed += (targetSpeed - state.speed) * dt * 0.5;
            // Drag
            state.speed *= 0.999;
            
            // Stall prevention (minimum lift speed)
            if(state.speed < 0 && plane.position.y > 0) state.speed = 0;

            // 2. Rotation Inputs
            const pitchSpeed = 1.2 * dt;
            const rollSpeed = 1.5 * dt;
            const yawSpeed = 0.5 * dt;

            // Local Rotation Accumulators
            let dPitch = 0;
            let dRoll = 0;
            let dYaw = 0;

            if(state.keys['arrowup']) dPitch = -pitchSpeed;
            if(state.keys['arrowdown']) dPitch = pitchSpeed;
            if(state.keys['arrowleft']) dRoll = rollSpeed;
            if(state.keys['arrowright']) dRoll = -rollSpeed;
            if(state.keys['q']) dYaw = yawSpeed;
            if(state.keys['e']) dYaw = -yawSpeed;

            // Auto-leveling (stability)
            if(!state.keys['arrowleft'] && !state.keys['arrowright']) {
               // dRoll -= state.roll * dt; // Simple damping
            }

            // Apply Rotations to Quaternion
            const qRot = new THREE.Quaternion();
            qRot.setFromEuler(new THREE.Euler(dPitch, dYaw, dRoll, 'XYZ'));
            plane.quaternion.multiply(qRot);

            // Bank-to-Turn Logic: Rolling creates Yaw force
            // Extract Roll
            const euler = new THREE.Euler().setFromQuaternion(plane.quaternion);
            const bankForce = -euler.z * dt * 0.5;
            const bankQ = new THREE.Quaternion().setFromAxisAngle(up, bankForce);
            plane.quaternion.premultiply(bankQ); // Global yaw based on local roll

            // 3. Movement
            // Get forward vector from quaternion
            const dir = forward.clone().applyQuaternion(plane.quaternion);
            
            // Velocity Vector
            // Speed in m/s (approx conversion from km/h visual scale)
            const moveSpeed = (state.speed / 3.6) * dt * 5; 
            
            // Gravity effect
            // If speed is low, plane drops
            const lift = Math.min(1, state.speed / 300); // 300 km/h is takeoff speed
            const gravity = -9.8 * dt * (1 - lift);
            
            velocity.copy(dir).multiplyScalar(moveSpeed);
            velocity.y += gravity;

            plane.position.add(velocity);

            // Ground Collision
            // We approximate ground height using the shader logic
            // Ideally we run the noise function here in JS to get exact height
            // For performance in this preview, we use a simple floor
            if(plane.position.y < 50) {
                plane.position.y = 50;
                // Crash bounce?
            }
            
            // 4. Update HUD Data
            state.altitude = plane.position.y;
            state.heading = (360 - (euler.y * (180/Math.PI)) % 360) % 360;

            // 5. Update Visuals
            plane.userData.flame.visible = state.engineOn && state.throttle > 0.2;
            plane.userData.flame.scale.z = state.throttle;
        }

        function updateCamera() {
            // Chase Camera
            const offset = new THREE.Vector3(0, 8, 30);
            offset.applyQuaternion(plane.quaternion);
            const cameraPos = plane.position.clone().add(offset);
            
            // Smooth follow
            camera.position.lerp(cameraPos, 0.1);
            camera.lookAt(plane.position);
        }

        function updateTerrain() {
            // Move ground to center under plane for "Infinite" illusion
            ground.position.x = plane.position.x;
            ground.position.z = plane.position.z;
        }

        function updateHUD() {
            document.getElementById('speed').innerText = Math.round(state.speed);
            document.getElementById('alt').innerText = Math.round(state.altitude);
            document.getElementById('hdg').innerText = Math.round(state.heading).toString().padStart(3, '0');
            document.getElementById('thr').innerText = Math.round(state.throttle * 100);
        }


        // --- MAIN LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const dt = clock.getDelta();

            updatePhysics(dt);
            updateCamera();
            updateTerrain();
            updateHUD();

            if(state.engineOn) updateAudio(state.throttle);

            renderer.render(scene, camera);
        }

        // Init - Fade out loader
        setTimeout(() => {
            document.getElementById('loader').style.opacity = 0;
            setTimeout(() => document.getElementById('loader').style.display = 'none', 1000);
        }, 1500);

        animate();

    </script>
</body>
</html>


